<?php

/*
 * libkinetic
 *
 * Copyright (C) 2018 SOFe
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

declare(strict_types=1);

namespace SOFe\Libkinetic;

use InvalidArgumentException;
use SOFe\Libkinetic\Base\IdComponent;
use SOFe\Libkinetic\Parser\XmlFileParser;
use function array_slice;
use function basename;
use function ctype_digit;
use function ctype_lower;
use function ctype_upper;
use function dirname;
use function explode;
use function fopen;
use function fwrite;
use function get_class;
use function htmlspecialchars;
use function implode;
use function is_file;
use function json_encode;
use function mkdir;
use function realpath;
use function str_repeat;
use function str_replace;
use function strlen;
use function strpos;
use function strtoupper;
use const PHP_EOL;

(function(){

})();

require_once __DIR__ . "/../cli-autoload.php";

if(!isset($argv[4])){
	throw new InvalidArgumentException("Usage: php $argv[0] def <xml file> <src> <fqn> [eol lf|crlf] [spaces <indent size>] [struct \"interface|([abstract|final] class)\"]");
}
$file = $argv[2];
if(!is_file($file)){
	throw new InvalidArgumentException("$file is not a file");
}

$parser = new XmlFileParser(fopen($file, "rb"), basename($file));

try{
	$parser->parse();
}catch(InvalidNodeException $e){
	echo "Invalid: {$e->getMessage()}\n";
	if(strpos(__FILE__, "phar://") !== 0){
		echo $e->getTraceAsString() . "\n";
	}
	exit(1);
}catch(ParseException $e){
	echo "Parse error: {$e->getMessage()}\n";
	exit(1);
}

$EOL = PHP_EOL;
$INDENT = "\t";
$STRUCT = "interface";

for($i = 5; isset($argv[$i + 1]); ++$i){
	if($argv[$i] === "eol"){
		$EOL = $argv[++$i] === "crlf" ? "\r\n" : "\n";
	}elseif($argv[$i] === "spaces"){
		$INDENT = str_repeat(" ", (int) $argv[++$i]);
	}elseif($argv[$i] === "struct"){
		$STRUCT = $argv[++$i];
	}
}

$phpFile = realpath($argv[3]) . "/" . str_replace("\\", "/", $argv[4]) . ".php";
$fqn = explode("\\", $argv[4]);
@mkdir(dirname($phpFile), 0777, true);

$php = fopen($phpFile, "wb");
fwrite($php, "<?php{$EOL}{$EOL}");
fwrite($php, "/*{$EOL}");
fwrite($php, " * libkinetic node ID {$STRUCT}{$EOL}");
fwrite($php, " *{$EOL}");
fwrite($php, " * This file is automatically generated by libkinetic-def{$EOL}");
fwrite($php, " */{$EOL}{$EOL}");
fwrite($php, "declare(strict_types=1);{$EOL}{$EOL}");
fwrite($php, "namespace " . implode("\\", array_slice($fqn, 0, -1)) . ";{$EOL}{$EOL}");
fwrite($php, "{$STRUCT} " . array_slice($fqn, -1)[0] . "{");

$idNodes = [];
foreach($parser->getAllNodes() as $node){
	if($node->hasComponent(IdComponent::class)){
		$id = $node->asIdComponent()->getId();
		if($id !== null){
			$key = $up = toUpperCase($id);
			for($i = 2; isset($idNodes[$key]); $i++){
				$key = $up . "_" . $i;
			}
			$idNodes[toUpperCase($id)] = [
				"id" => $id,
				"class" => array_slice(explode("\\", get_class($node)), -1)[0],
				"name" => $node->getHumanName(),
				"hierarchy" => $node->getParent()->getHierarchyName(),
			];
		}
	}
}

foreach($idNodes as $name => $node){
	$id = json_encode($node["id"]);
	fwrite($php, "{$EOL}{$INDENT}/**${EOL}");
	$hierarchy = htmlspecialchars($node["hierarchy"]);
	fwrite($php, "{$INDENT} * &lt;{$node["name"]}&gt; {$id} in {$hierarchy}${EOL}");
	fwrite($php, "{$INDENT} */${EOL}");
	fwrite($php, "{$INDENT}public const {$name} = $id;{$EOL}");
}

fwrite($php, "}{$EOL}");

function toUpperCase(string $string) : string{
	$lastType = 0; // 0 = separator, 1 = lower, 2 = upper, 3 = digit

	$words = [];
	$word = "";
	for($i = 0, $iMax = strlen($string); $i < $iMax; $i++){
		switch(true){
			case ctype_lower($string{$i}):
				if($lastType === 3){ // 3a
					$words[] = $word;
					$word = "";
				}
				$word .= strtoupper($string{$i});
				$lastType = 1;
				break;
			case ctype_upper($string{$i}):
				if($lastType === 1 || $lastType === 3){ // aB or 3B
					$words[] = $word;
					$word = "";
				}
				$word .= $string{$i};
				$lastType = 2;
				break;
			case ctype_digit($string{$i}):
				if($lastType === 1 || $lastType === 2){
					$words[] = $word;
					$word = "";
				}
				$word .= $string{$i};
				$lastType = 3;
				break;
			default:
				if($word !== ""){
					$words[] = $word;
					$word = "";
				}
				$lastType = 0;
				break;
		}
	}

	if($word !== ""){
		$words[] = $word;
	}

	$ret = implode("_", $words);
	if(ctype_digit($ret{0})){
		$ret = "_" . $ret;
	}
	return $ret;
}

exit(0);
